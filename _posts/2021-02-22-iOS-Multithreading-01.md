---
title: 멀티 스레드

layout: single
comments: true
share: true
categories: 
- iOS
tag:
- Multithreading
last_modified_at: 2021-12-26 T00:00:00+08:00
---

## 멀티 스레드란?

시스템 레벨에서 프로그램은 나란히(side by side) 실행되며 시스템은 각 프로그램의 필요성에 따라 프로그램에 실행 시간을 할당한다. 프로그램 내부에는 여러 작업을 동시에(또는 거의 동시에) 수행하는 데 사용할 수 있는 하나 이상의 실행 스레드가 있는데, 시스템은 이러한 실행 스레드를 관리하고 사용 가능한 코어에서 실행되도록 예약하거나 필요한 경우 다른 스레드가 실행될 수 있도록 인터럽트한다.

기술적인 관점에서 스레드는 코드 실행을 관리하는데 필요한 커널 수준(kernel-level) 및 응용 프로그램 수준(application-level) 데이터 구조의 조합이다. 커널 수준의 구조는 스레드에 대한 이벤트 디스패치 및 사용 가능한 코어 중 하나에 스레드의 선점 스케줄링을 조정한다. 응용 프로그램 수준의 구조는 함수 호출을 저장하기 위한 호출 스택과 응용 프로그램이 스레드의 속성 및 상태를 관리하고 조작하는데 필요한 구조가 포함된다.

비동시(non-concurrent) 응용 프로그램에는 실행 스레드가 하나만 존재한다. 따라서 이 스레드는 응용 프로그램의 메인 루틴으로 시작하여 끝나며 응용 프로그램의 전체 동작을 구현하기 위해 다른 메서드나 함수로 하나씩 분기됩니다. 반대로 동시성을 지원하는 애플리케이션은 하나의 스레드로 시작하여 추가적인 실행 경로를 생성하기 위해 필요에 따라 스레드를 추가한다. 각 새 경로에는 응용 프로그램의 메인 루틴에 있는 코드와 독립적으로 실행되는 고유한 사용자 정의 시작 루틴이 있다. 멀티 스레드는 다음과 같은 두 가지 중요한 이점이 있다.

- 멀티 스레드는 애플리케이션의 응답성(perceived responsiveness)을 향상 시킬 수 있다.

애플리케이션에 스레드가 하나만있는 경우 해당 스레드가 모든 작업을 수행해야 하는데,  문제는 한 번에 하나의 작업만 수행 할 수 있다는 것이다. 만약 특정 작업이 완료되는데 오랜 시간이 걸리게 된다면, 코드가 필요한 값을 계산하는 동안에는 애플리케이션이 사용자 이벤트에 대한 응답과 윈도우 업데이트를 중지할 것이다. 이러한 상황이 오래 지속되면 사용자는 응용 프로그램이 중단 되었다고 생각하고 강제로 종료하려고 할 수 있다. 

- 다중 스레드는 멀티 코어 시스템에서 애플리케이션의 실시간 성능을 향상시킬 수 있다.

멀티 코어 컴퓨터에서 스레드는 일부 유형의 애플리케이션에서 성능을 향상시키는 방법을 제공한다. 서로 다른 작업을 수행하는 스레드는 서로 다른 프로세서 코어에서 동시에 수행할 수 있으므로 응용 프로그램이 주어진 시간 동안 수행하는 작업의 양을 늘릴 수 있다.

물론 스레드는 응용 프로그램의 성능 문제를 해결하기위한 만병 통치약은 아니다. 스레드가 제공하는 이점과 함께 잠재적인 문제가 발생하기도 한다. 응용 프로그램에서 여러 실행 경로를 사용하면 코드가 상당히 복잡해질 수 있다. 각 스레드는 응용 프로그램의 상태 정보가 손상되지 않도록 다른 스레드와 작업을 조정해야한다. 단일 애플리케이션의 스레드는 동일한 메모리 공간을 공유하기 때문에 같은 데이터 구조에 액세스 할 수 있다. 두 스레드가 같은 데이터 구조를 동시에 조작하려고 하면 한 스레드가 다른 스레드의 변경 사항을 덮어 쓰고 결과 데이터 구조가 손상 될 수 있다. 

## iOS에서의 멀티 스레딩 구현 방법

### **GCD** vs **NSOperation**

`NSOperation`과 GCD 모두 작업 단위를 캡슐화해서 실행을 위해 디스패치 할 수 있게 설계되어 있으며, UI Main 스레드와 분리되어 여러 스레드에서 무거운 작업을 수행하도록 해준다.

### **GCD - Low-level API**

Dispatch queue에 들어온 작업을 serially, concurrently 방식으로 수행할 수 있다. 이 작업들은 시스템에의해 관리되는 스레드 풀에서 수행된다. 작업 아이템을 동기, 비동기 방식으로 지정할 수 있으며, 단순한 구현에 적합하다.

[GCD에 대해 정리한 글](https://hyunsikwon.github.io/ios/iOS-GCD/)


### NSOperation  - Objective-C 기반 추상 클래스

`NSOperationQueue`는 GCD와 비교할때 다음과 같은 장점이 있다.

- dependecy

작업들 사이의 의존성을 추가할 수 있다. 이를 통해 작업의 수행 순서를 지정해줄 수 있다. 많은 병렬 프로세싱이 필요한 작업(수학 방적식)을 위해 사용된다. 병렬 작업들은 서로 의존되는 경우가 많기 때문이다. 예를 들어, 어떤 코드 블럭에 의존하는 작은 코드 블럭이 있다면 이것들을 다 실행하고 필요한 블록이 종료되길 기다리는 것이다.

- Pause, Cancel, Resume

GCD Dispatch는 작업을 보낸 후에는 통제할 수 없는데 반해 `NSOperation`을 중지, 취소, 재게할 수 있다. 또한, 동시에 수행될 최대 작업의 수를 지정할 수 있다. 

- Observable

`NSOpration`, `NSOperationQueue` 클래스는 KVO를 사용하여 관찰(observe)될 수 있는 여러 프로퍼티를 가진다. 

## Reference

[Apple Document](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW3)
